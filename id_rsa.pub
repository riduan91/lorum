from datetime import timedelta
from dateutil.relativedelta import relativedelta
from sqlalchemy import func, and_

def _jan1_of_year_of(d):
    # d is a pandas.Timestamp or datetime.date
    return d.replace(month=1, day=1)

def _year_window_bounds_sql_style(dat):
    """
    Reproduce the SQL logic:
      upper <= Jan 1 of (dat + 1 day)
      lower >  Jan 1 of ((dat - 1 year) + 1 day)
    Window is (lower, upper]
    """
    dat = pd.to_datetime(dat).date()
    upper = _jan1_of_year_of(dat + timedelta(days=1))
    lower = _jan1_of_year_of((dat - relativedelta(years=1)) + timedelta(days=1))
    return lower, upper

def _safe_ratio(num, den):
    try:
        den = float(den) if den is not None else 0.0
        num = float(num) if num is not None else 0.0
        return (num / den) if den != 0.0 else 0.0
    except Exception:
        return 0.0

def _get_esg_voting_single(i, dat, code, fkey):
    session = get_session()
    try:
        dat = pd.to_datetime(dat)
        lower, upper = _year_window_bounds_sql_style(dat)

        # 2a. Latest vote date within SQL-style window
        max_vote_date = (
            session.query(func.max(DWGNProductVote.datVoteValuDt))
            .filter(
                DWGNProductVote.strProdCd == code,
                DWGNProductVote.strVoteValuDtRng == "Y",
                DWGNProductVote.strProdVoteOrigin != "Std",
                DWGNProductVote.datVoteValuDt <= upper,
                DWGNProductVote.datVoteValuDt > lower,
            )
            .scalar()
        )

        if not max_vote_date:
            # mimic "no update": return empty (will not overwrite)
            return {
                "datPeriodLastDay": dat, "strPortfGPSCode": code, "numPortfGroupFKey": fkey,
                # leave metrics as None so we can combine_first() later
                "numNumMeetingsVoted": None,
                "numPctgMeetingsVotedWithResv": None,
                "numPctgMeetingsVotedFor": None,
                "numNumItemsVoted": None,
                "numPctgVotesFor": None,
                "numPctgVotesAbstain": None,
                "numPctgVotesAgainst": None,
                "numPctgVotesWithhold": None,
                "numNumFRMeetingsWithVotes": None,
                "numPctgFRMeetingsWithVotes": None,
                "numNumNonFRMeetingsWithVotes": None,
                "numPctgNonFRMeetingsWithVotes": None,
            }

        # 2b. Latest extraction for that vote date (global max)
        max_extraction = (
            session.query(func.max(DWGNProductVote.datExtractionTS))
            .filter(
                DWGNProductVote.strProdCd == code,
                DWGNProductVote.datVoteValuDt == max_vote_date,
            )
            .scalar()
        )

        # 3. Fetch vote record BUT reapply the filters; if the max extraction belongs to a row
        # that doesn't pass filters, SQL yields no row (no update).
        vote = (
            session.query(DWGNProductVote)
            .filter(
                DWGNProductVote.strProdCd == code,
                DWGNProductVote.datVoteValuDt == max_vote_date,
                DWGNProductVote.datExtractionTS == max_extraction,
                DWGNProductVote.strVoteValuDtRng == "Y",
                DWGNProductVote.strProdVoteOrigin != "Std",
            )
            .first()
        )

        if not vote:
            return {
                "datPeriodLastDay": dat, "strPortfGPSCode": code, "numPortfGroupFKey": fkey,
                "numNumMeetingsVoted": None,
                "numPctgMeetingsVotedWithResv": None,
                "numPctgMeetingsVotedFor": None,
                "numNumItemsVoted": None,
                "numPctgVotesFor": None,
                "numPctgVotesAbstain": None,
                "numPctgVotesAgainst": None,
                "numPctgVotesWithhold": None,
                "numNumFRMeetingsWithVotes": None,
                "numPctgFRMeetingsWithVotes": None,
                "numNumNonFRMeetingsWithVotes": None,
                "numPctgNonFRMeetingsWithVotes": None,
            }

        # 4. Compute metrics (SQL semantics: 0 when denominator is 0/NULL)
        n_items = vote.numNumItemsVoted
        pct_for      = _safe_ratio(vote.numNumVotesFor,      n_items)
        pct_abstain  = _safe_ratio(vote.numNumVotesAbstain,  n_items)
        pct_against  = _safe_ratio(vote.numNumVotesAgainst,  n_items)
        pct_withhold = _safe_ratio(vote.numNumVotesWithhold, n_items)

        pct_meet_withresv = float(vote.numPctgMeetingsVotedWithResv or 0.0)

        return {
            "datPeriodLastDay": dat,
            "strPortfGPSCode": code,
            "numPortfGroupFKey": fkey,
            "numNumMeetingsVoted": float(vote.numNumMeetingsVoted or 0.0),
            "numPctgMeetingsVotedWithResv": pct_meet_withresv,
            "numPctgMeetingsVotedFor": 1.0 - pct_meet_withresv,
            "numNumItemsVoted": float(n_items or 0.0),
            "numPctgVotesFor": pct_for,
            "numPctgVotesAbstain": pct_abstain,
            "numPctgVotesAgainst": pct_against,
            "numPctgVotesWithhold": pct_withhold,
            "numNumFRMeetingsWithVotes": vote.numNumFRMeetingsWithVotes,
            "numPctgFRMeetingsWithVotes": vote.numPctgFRMeetingsWithVotes,
            "numNumNonFRMeetingsWithVotes": vote.numNumNonFRMeetingsWithVotes,
            "numPctgNonFRMeetingsWithVotes": vote.numPctgNonFRMeetingsWithVotes,
        }
    finally:
        session.close()
